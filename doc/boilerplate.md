# Avoiding "parameter-passing"

One downside of using explicit components to implement a given behaviour is that we have to pass those components down to every place where they are used.
This is an area where the "MTL approach", relying on typeclasses to describe interfaces, is more convenient.

What we would like to write is:

```
implementService ::
     Monad m
  => WithLogger m
  => WithTracer m
  => Int
  -> Text
  -> m ()
implementService n t = do
  info t
  traceIt (show n)
```

where `info` and `traceIt` are functions from the `WithLogger` and `WithTracer` typeclasses. Otherwise we have to write:
```
implementService ::
     Monad m
  -> Logger m
  -> Tracer m
  -> Int
  -> Text
  -> m ()
implementService logger tracer n t = do
  info logger t
  traceIt tracer (show n)
```

This doesn't seem *that* bad like this but if `implementService` is delegating some work to other functions and so on, we get to manually pass `logger` and `tracer` in many places.

## With typeclasses

It is possible to get around this boilerplate by creating the typeclass corresponding to a given component with a bit of Template Haskell

```
{-# LANGUAGE TemplateHaskell #-}

module Test.Data.Registry.THSpec where

-- IMPORTANT! You have to import the Typed module from generic-lens because
-- the typeclass instance generated by makeTypeclass needs it
import           Data.Generics.Product.Typed
import           Data.Registry.TH
import           Protolude

data Logger m = Logger {
  -- a function taking 2 arguments
  _info  :: Text -> Text -> m ()
  -- a function having a constraint
, _error :: forall a . (Monoid a) => a -> Text -> m ()
}

makeTypeclass ''Logger
```
This generates the following code
```
class WithLogger m where
  info  :: Text -> Text -> m ()
  error :: forall a . (Monoid a) => a -> Text -> m ()

instance (HasType (Logger m) s) => WithLogger (ReaderT s m) where
  info t1 t2 = ReaderT (\s -> _info (getTyped s) t1 t2)
  error a t  = ReaderT (\s -> _error (getTyped s) a t)
```

This means that you can now implement a given component using the `WithLogger` typeclass instead of using a `Logger` directly. For example, let's specify another component, `Tracer` and a `Service` using both a `Logger` and a `Tracer`
```
newtype Tracer m = Tracer {
  _traceIt :: Text -> m ()
}

makeTypeclass ''Tracer

newtype Service m = Service {
  doIt :: Int -> Text -> m ()
}

newService :: Monad m => Logger m -> Tracer m -> Service m
newService logger tracer = Service {
  doIt = <something here> implementService
}

-- | Implement the service using typeclasses
implementService ::
     Monad m
  => WithLogger m
  => WithTracer m
  => Int
  -> Text
  -> m ()
implementService n t = do
  info "doing it" t
  traceIt (show n)
```

As you can see we don't need to pass `logger` or `tracer` to `implementService` in order to use their functions. Nice!
However we still have to fill a blank `<something here>`. Indeed we need to find a monad which is implementing both `WithLogger m` and `WithTracer m`.

## And a bit of help from `generic-lens`

The solution is given by the `ReaderT` instance which is also generated by `makeTypeclass`. This instance uses a typeclass from `generic-lens`, `HasType c s`, describing that we can extract a component of type `c` from something of type `s`. For example from a tuple containing all our components:
```
newService :: Monad m => Logger m -> Tracer m -> Service m
newService logger tracer = Service {
  -- or doIt = run ... implementService using Universum (...) operator
  doIt n t = run $ implementService n t
} where
    run = flip runReaderT (logger, tracer)
```

With this approach we can write most of our code with typeclass definitions for the functions we want use while using some concrete components for the wiring.

## Generation options

The `makeTypeclass` function uses some conventions to create the typeclass associated to a given component:

 - the name of the typeclass is `With<ComponentName>`
 - the names of the typeclass functions are the names of the component functions minus their first character. So if you prefix them with `_` as the example above you will get "nice" function names in your typeclass

You can change those 2 defaults by using the `makeTypeclassWith` function and passing a custom `TypeclassOptions` value
```
makeTypeclassWith (TypeClassOptions {
  _typeclassName t = "Has" <> t
, _functionName t  = dropPrefix t
})
```
