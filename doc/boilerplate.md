# Addressing "parameter-passing"

One downside of using explicit components to implement a given behaviour is that we have to pass those components down to every place where they are used.
This is an area where the "MTL approach", relying on typeclasses to describe interfaces, is more convenient.

What we would like to write is:

```
implementService ::
     Monad m
  => WithLogger m
  => WithTracer m
  => Int
  -> Text
  -> m ()
implementService n t = do
  info t
  traceIt (show n)
```

where `info` and `traceIt` are functions from the `WithLogger` and `WithTracer` typeclasses. Otherwise we have to write:
```
implementService ::
     Monad m
  -> Logger m
  -> Tracer m
  -> Int
  -> Text
  -> m ()
implementService logger tracer n t = do
  info logger t
  traceIt tracer (show n)
```

This doesn't seem *that* bad like this but if `implementService` is delegating some work to other functions and so on, we get to manually pass `logger` and `tracer` in many places.

## With typeclasses

It is possible to get around this boilerplate by creating the typeclass corresponding to a given component with a bit of Template Haskell

```
{-# LANGUAGE TemplateHaskell #-}

module Test.Data.Registry.THSpec where

import           Data.Registry.TH
import           Protolude

data Logger m = Logger {
  -- a function taking 2 arguments
  _info  :: Text -> Text -> m ()
  -- a function having a constraint
, _error :: forall a . (Monoid a) => a -> Text -> m ()
}

makeTypeclass ''Logger
```
This generates the following code
```
class WithLogger m where
  info  :: Text -> Text -> m ()
  error :: forall a . (Monoid a) => a -> Text -> m ()

instance (HasType (Logger m) s) => WithLogger (ReaderT s m) where
  info t1 t2 = ReaderT (\s -> _info (getTyped s) t1 t2)
  error a t  = ReaderT (\s -> _error (getTyped s) a t)
```

This means that you can now implement a given component using the `WithLogger` typeclass instead of using a `Logger` directly. For example, let's specify another component, `Tracer` and a `Service` using both a `Logger` and a `Tracer`
```
newtype Tracer m = Tracer {
  _traceIt :: Text -> m ()
}

makeTypeclass ''Tracer

newtype Service m = Service {
  doIt :: Int -> Text -> m ()
}

newService :: Monad m => Logger m -> Tracer m -> Service m
newService logger tracer = Service {
  doIt = <something here> implementService
}

-- | Implement the service using typeclasses
implementService ::
     Monad m
  => WithLogger m
  => WithTracer m
  => Int
  -> Text
  -> m ()
implementService n t = do
  info "doing it" t
  traceIt (show n)
```

As you can see we don't need to pass `logger` or `tracer` to `implementService` in order to use their functions. Nice!
However we still have to fill a blank `<something here>`. Indeed we need to find a monad which is implementing both `WithLogger m` and `WithTracer m`. The solution is given by the `ReaderT` instance which is also generated by `makeTypeclass`. This instance allows us to run some code with a tuple containing our components:
```
newService :: Monad m => Logger m -> Tracer m -> Service m
newService logger tracer = Service {
  -- or doIt = run ... implementService using Universum (...) operator
  doIt n t = run $ implementService n t
} where
    run = flip runReaderT (logger, tracer)
```

With this approach we can write most of our code with typeclass definitions for the functions we want use while using some concrete components for the wiring.
